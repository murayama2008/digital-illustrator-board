# PaperOS: A 16-bit Monolithic Real-Mode Operating System
# v2.0.1
## 1. Project Abstract

PaperOS is an experimental, open-source monolithic operating system developed in x86 Assembly (NASM) and C. It functions within the 16-bit Real Mode environment, interacting directly with system hardware components such as the CPU registers, BIOS interrupts, memory addresses, and Input/Output ports without the abstraction layers found in modern kernels.

This project serves as a comprehensive study in low-level systems programming, demonstrating the implementation of a custom filesystem with metadata persistence, sector-level encryption, direct hardware audio synthesis, and hybrid peripheral interfacing via serial communication bridges. PaperOS v1.9.7 introduces significant advancements in data persistence, implementing a 32-byte header structure for file metadata management on raw floppy media.

## 2. System Architecture and Design

The core architecture of PaperOS is built upon the segmented memory model of the Intel 8086 architecture. The kernel resides in the boot sector and extends into the lower memory, managing hardware resources through direct port manipulation and BIOS interrupt calls.

### 2.1 Memory Management

PaperOS operates within the first megabyte of memory (Real Mode). It utilizes a segmented addressing scheme (Segment:Offset) to access memory regions. The kernel manually manages the stack pointer (`SP`) and data segments (`DS`, `ES`), ensuring that user-space operations—such as text editing buffers—do not corrupt the kernel executable code or the Interrupt Vector Table (IVT).

### 2.2 The Custom Filesystem (PFS)

Unlike standard FAT12 or EXT filesystems, PaperOS implements a proprietary, raw-sector storage mechanism optimized for security and metadata retention. This system bypasses standard filesystem drivers, performing Input/Output operations directly via Cylinder-Head-Sector (CHS) addressing using `INT 13h`.

**Storage Layout Strategy:**

* **Head 0 (System Partition):** Reserved exclusively for the Bootloader and Kernel binary. This ensures that user data operations never overwrite critical system code.
* **Head 1 (User Vault Partition):** Dedicated to user data storage. Slots 1, 2, and 3 map to specific sectors (Sector 10, 11, and 12) on this head.

**Sector Structure (32-Byte Header):**
With version 1.9.7, the sector layout was refactored to support metadata. Each 512-byte sector is structured as follows:

* **Bytes 0x00 - 0x07 (8 Bytes):** **Security Key.** Stores the user-defined password for the sector.
* **Byte 0x08 (1 Byte):** **Lock Status Flag.** A binary flag indicating if the sector is encrypted (1) or open (0).
* **Byte 0x09 (1 Byte):** **Retry Counter.** Tracks failed authentication attempts. A value of 3 triggers the automated data destruction sequence.
* **Bytes 0x0A - 0x15 (12 Bytes):** **Filename Metadata.** Stores the user-assigned alphanumeric name of the file (e.g., "SECRET_DOC").
* **Bytes 0x16 - 0x1F (10 Bytes):** **Reserved/Padding.** Allocated for future expansion (e.g., timestamps or permission flags).
* **Bytes 0x20 - 0x1FF (480 Bytes):** **Data Payload.** The actual text content created by the user.

## 3. The Serial Mouse Bridge Mechanism

A distinguishing feature of PaperOS is its hybrid approach to peripheral input, specifically regarding the mouse driver. Due to the complexities of implementing a full PS/2 mouse driver stack in a limited 16-bit environment, PaperOS utilizes a "Split-Driver" architecture involving a host-side C program and a guest-side Assembly interrupt handler.

### 3.1 The Host Controller (`bridge.c`)

The `bridge.c` program operates on the host Linux machine. Its primary function is to interface between the modern Linux input subsystem and the virtualized environment of PaperOS.

* **Input Acquisition:** The program opens the `/dev/input/mice` character device file. It reads the raw byte stream generated by the host's physical mouse movement and button clicks.
* **Protocol Translation:** The C program parses the raw input data. Upon detecting a left-click or right-click event, it generates a simplified, single-character signal ('L' for Left, 'R' for Right).
* **TCP Transmission:** The bridge establishes a TCP socket connection to the QEMU instance running PaperOS. QEMU is configured to redirect its virtual Serial Port (COM1) to this TCP socket (`tcp:127.0.0.1:4444`).
* **Data Injection:** The signal characters are transmitted over the socket, effectively simulating serial data arriving at the guest OS's UART port.

### 3.2 The Guest Handler (`kernel.asm`)

Inside PaperOS, the kernel initializes the UART 8250 controller (COM1 port at `0x3F8`) during the boot sequence.

* **Initialization:** The kernel configures the Baud Rate Divisor to match the transmission speed and enables the FIFO queues.
* **Polling/Interrupts:** The kernel monitors the Line Status Register (LSR) at port `0x3FD`. When the "Data Ready" bit is set, it implies that the `bridge.c` program has sent a signal.
* **Execution:** The kernel reads the byte from the Receive Buffer Register (`0x3F8`). If it receives an 'L', it triggers the Left Click routine; if 'R', it triggers the Right Click routine. This allows PaperOS to respond to modern hardware inputs through a legacy interface.

## 4. Kernel Features and Utilities

### 4.1 Vault Security System

PaperOS implements a rudimentary but effective security model at the sector level.

* **Authentication:** Accessing a protected slot triggers the `_verify_access` routine. The user must input a password which is compared against the first 8 bytes of the sector header.
* **Brute-Force Protection:** The system utilizes a non-volatile counter stored in Byte 0x09 of the sector. Every failed attempt increments this counter and writes it back to the disk immediately.
* **Self-Destruct Mechanism:** If the counter reaches three failed attempts, the kernel initiates a wiping procedure, overwriting the entire 512-byte sector with null bytes (`0x00`), rendering the data irretrievable.

### 4.2 PaperEdit v1.3 (Text Editor)

The integrated text editor provides a visual interface for data manipulation.

* **Dynamic Buffering:** It loads sector data into a RAM buffer starting at offset 0x20 (Byte 32) to preserve metadata headers.
* **Visual Formatting:** It interprets ASCII control characters, rendering Carriage Returns (CR) and Line Feeds (LF) as visual line breaks, and implements a visual margin system using the pipe character (`|`) for UI consistency.
* **Synchronous I/O:** Changes are strictly in-memory until the user issues the save command (ESC), which commits the buffer to the floppy disk.

### 4.3 16-Bit Arithmetic Logic Unit (Calculator v4.0)

The system includes a mathematical coprocessor utility capable of handling unsigned 16-bit integers.

* **Range:** Operations are valid for integers from 0 to 65,535.
* **Operations:** Supports Addition, Subtraction, Multiplication, and Division.
* **Remainder Handling:** The division routine utilizes the `DX` register to capture and display the remainder (modulus) of integer division, ensuring precision in non-floating-point calculations.

### 4.4 Audio Synthesis Engine

PaperOS drives the PC Speaker directly via the Programmable Interval Timer (PIT 8253) chip.

* **Square Wave Generation:** The kernel manipulates Port `0x43` (Mode Command) and Port `0x42` (Channel 2 Data) to set the frequency divisor.
* **Timing:** Duration is controlled via BIOS Interrupt `15h` (Wait Function), allowing for precise musical note sequencing.
* **Repertoire:** The OS includes hardcoded frequency arrays for melodies such as "Daisy Bell" and "Silent Night."

## 5. Technical Prerequisites

To compile and run PaperOS, the following development tools are required on a Linux host environment (Fedora, Debian, or Ubuntu):

* **NASM (Netwide Assembler):** Required to assemble the x86 source code into a flat binary format.
* **GCC (GNU Compiler Collection):** Required to compile the C-based mouse bridge utility.
* **QEMU (Quick Emulator):** Required to virtualize the x86 hardware environment, specifically the floppy drive controller and serial ports.
* **DD Utility:** Required for low-level binary copying and disk image creation.

## 6. Installation and Deployment

Follow these instructions to build the kernel and initialize the simulation environment.

### 6.1 Compiling the Kernel

Assemble the source code into a raw binary file.

```bash
nasm -f bin kernel.asm -o kernel.bin

```

### 6.2 Creating the Disk Image

Create a blank 1.44MB floppy disk image filled with zeros, then write the kernel binary to the boot sector (Sector 0).

```bash
dd if=/dev/zero of=paperos.img bs=512 count=2880
dd if=kernel.bin of=paperos.img conv=notrunc

```

### 6.3 Compiling the Mouse Bridge

Compile the host-side controller.

```bash
gcc bridge.c -o bridge

```

### 6.4 Execution

Launch the QEMU emulator with specific flags to enable audio (PulseAudio) and redirect the serial port to a TCP server for the mouse bridge.

```bash
qemu-system-x86_64 -drive format=raw,file=paperos.img \
    -audiodev pa,id=snd0,out.frequency=44100 \
    -machine pcspk-audiodev=snd0 \
    -serial tcp:127.0.0.1:4444,server,nowait

```

*In a separate terminal window, execute the bridge to link the mouse:*

```bash
./bridge

```

## 7. Command Reference Manual

The PaperOS Shell (CLI) accepts the following commands:

**File Management**

* `ls` : Lists all storage slots, displaying status (Open/Locked) and filenames.
* `rename` : Assigns a persistent alphanumeric name to a storage slot.
* `read[1-3]` : Reads and displays the content of Slot 1, 2, or 3.
* `write[1-3]` : Opens the PaperEdit interface for the specified slot.
* `count[1-3]` : Returns the character count of the data in the specified slot.

**Security**

* `lock[1-3]` : Encrypts the specified slot with a new password.
* `unlock[1-3]` : Decrypts the specified slot (requires current password).

**System & Utilities**

* `calc` : Launches the 16-bit arithmetic calculator.
* `hwinfo` : Displays detected hardware (RAM size, FPU presence, Mouse).
* `fastfetch` : Displays system information and ASCII art logo.
* `mouse` : Activates the Serial Mouse listener mode.
* `beep` : Tests the PC Speaker hardware.
* `clear` : Clears the video memory buffer.
* `reboot` : Performs a soft reset of the system.
* `shutdown` : Powers off the system via APM (Advanced Power Management).
* `desktop` : Open the GUI mode (BETA TEST).

**Entertainment**

* `daisy` : Plays the "Daisy Bell" melody via PC Speaker.
* `christmas` : Plays "Silent Night" via PC Speaker.
* `gui` : Experimental graphical mode (Paper-Tron game concept).

